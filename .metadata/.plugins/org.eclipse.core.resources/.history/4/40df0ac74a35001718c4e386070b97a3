/* 클래스 로딩 절차
 * => JRE 라이브러리 폴더에서 클래스를 찾는다.
 * => 없으면, CLASSPATH 환경 변수에 지정된 폴더에서 클래스를 찾는다.
 * =>찾았으면, 그 클래스 파일이 올바른 바이트코드인지 검증한다.
 * => 올바른 바이트코드라면, Method Area 영역으로 파일을 로딩한다.
 * => 클래스 변수를 만들라는 명령어가 있으면 Method Area에 그 변수를 준비한다.
 * => 클래스 블록이 있으면 순서 대로 그 블록을 실행한다.
 */
package step07;

public class Test01_3 {
  // 1) 클래스 변수
  // => 변수 선언 앞에 static을 붙인다.
  // => 클래스 로딩한 후 자동으로 생성되는 변수이다.
  // => 클래스를 로딩하는 시점?
  //      1) new 명령을 사용하여 인스턴스를 생성할 때
  //      2) 클래스 변수를 사용하려 할 때
  //      3) 클래스 메서드를 사용하려 할 때
  //      이 세가지 경우에 해당 클래스 파일이 메모리에 로딩된다.
  //      즉 ***.class 파일을 메모리의 "Method Area" 영역으로 읽어 들인다.
  //      우리는 이것을 "클래스를 로딩한다" 라고 표현한다.
  //      => 클래스 변수는 클래스 이름이나 인스턴스 주소를 이용하여 접근할 수 있다.
  //      => 클래스명.클래스변수명
  //      => 인스턴스변수.클래스변수명
  static class Student {
    static String name;
    static int age;
    static boolean working;
    
    static void m1() {
      
    }
  }
  public static void main(String[] args) {
 // 클래스 로딩 시점을 확인하자!
    // 1) 레퍼런스 변수를 만들 때?
    Student s;
    
    // 2) 클래스 변수를 사용할 때 ? 클래스를 로딩한다.
    //=> 클래스 변수는 클래스라 로딩된 후에 생성된다고 하지 않았나!
    //      그러니 클래스 변수를 사용하기 전에 클래스가 로딩되어야 한다.
//    System.out.println(Student.name);
    
    // 3) 클래스 메서드를 호출할 때? 클래스를 로딩한다.
    // => 클래스의 메서드 호출하려면 클래스 코드가 메모리에 있어야 할 것 아닌가!
//    Student.m1();
    
    // 4) new 명령을 사용할 때? 클래스를 로딩한다.
    // => 인스턴스를 생성하려면 클래스 설계도가 필요하고,
    // => 인스턴스를 생성한 후 생성자 메서드를 호출해야 한다.
    //      그러니 당연히 클래스가 로딩되어야 한다.
    new Student();
  }

}
